name: ai-code-forge release

on:
  push:
    branches: [main]
    paths: 
      - '.claude/**'
      - 'templates/**' 
      - 'scripts/**'
      - 'docs/**'
      - 'acf/**'
      - 'CLAUDE.md'
      - 'README.md' 
      - 'CHANGELOG.md'
    tags:
      - 'v*'  # Semantic version tags (v0.2.0, v0.2.1, etc.)
  pull_request:
    paths:
      - '.claude/**'
      - 'templates/**'
      - 'scripts/**' 
      - 'docs/**'
      - 'acf/**'
      - 'CLAUDE.md'
      - 'README.md'
      - 'CHANGELOG.md'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - release
          - test
      create_release:
        description: 'Create GitHub release (only on main branch)'
        required: false
        default: false
        type: boolean
      version_override:
        description: 'Version override (leave empty for pyproject.toml version)'
        required: false
        type: string
      release_type:
        description: 'Release type'
        required: false
        default: 'release'
        type: choice
        options:
          - release
          - prerelease
          - draft

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read   # Minimal permissions for security
      actions: read
    env:
      SHOULD_RELEASE: ${{ (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.create_release == 'true') }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper version detection
          
      - name: Release validation and security checks
        if: env.SHOULD_RELEASE == 'true'
        run: |
          echo "🔒 Running release validation and security checks..."
          
          # Branch protection validation
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.ref }}" != "refs/heads/main" ]]; then
            echo "❌ ERROR: Manual releases must be created from main branch only"
            echo "Current ref: ${{ github.ref }}"
            exit 1
          fi
          
          # Tag format validation
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            TAG_VERSION=$(echo "${{ github.ref }}" | sed 's/refs\/tags\/v//')
            echo "Validating tag version: $TAG_VERSION"
            
            # Semantic version validation
            if [[ ! "$TAG_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "❌ ERROR: Tag must follow semantic versioning (v1.2.3, v1.2.3-rc.1, etc.)"
              echo "Invalid tag: $TAG_VERSION"
              exit 1
            fi
            
            # Version consistency validation
            PYPROJECT_VERSION=$(grep '^version = ' acf/pyproject.toml | sed 's/version = "//; s/"//')
            if [[ "$TAG_VERSION" != "$PYPROJECT_VERSION" ]]; then
              echo "❌ ERROR: Tag version ($TAG_VERSION) must match pyproject.toml version ($PYPROJECT_VERSION)"
              exit 1
            fi
            
            echo "✅ Version validation passed: $TAG_VERSION"
          fi
          
          # Determine release type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            RELEASE_VERSION=$(grep '^version = ' acf/pyproject.toml | sed 's/version = "//; s/"//')
            if [[ -n "${{ inputs.version_override }}" ]]; then
              RELEASE_VERSION="${{ inputs.version_override }}"
            fi
          else
            RELEASE_VERSION=$(echo "${{ github.ref }}" | sed 's/refs\/tags\/v//')
          fi
          
          # Prerelease detection
          IS_PRERELEASE="false"
          if [[ "$RELEASE_VERSION" =~ (alpha|beta|rc|dev) ]]; then
            IS_PRERELEASE="true"
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.release_type }}" == "prerelease" ]]; then
            IS_PRERELEASE="true"
          fi
          
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "IS_PRERELEASE=$IS_PRERELEASE" >> $GITHUB_ENV
          
          echo "📋 Release configuration:"
          echo "  Version: $RELEASE_VERSION"
          echo "  Prerelease: $IS_PRERELEASE"
          echo "  Event: ${{ github.event_name }}"
          
      - name: Setup Python and uv  
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          
      - name: Cache uv dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ hashFiles('acf/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-uv-
            
      - name: Prepare ACF package data
        run: |
          echo "=== Preparing ACF Package Data ==="
          mkdir -p acf/src/acf/data/{claude,acf}
          
          # Copy Claude Code files
          echo "Copying .claude directory..."
          cp -r .claude/* acf/src/acf/data/claude/
          
          # Copy ACF-managed files
          echo "Copying templates, scripts, docs..."
          cp -r templates scripts docs acf/src/acf/data/acf/
          
          # Copy ACF tool documentation
          echo "Copying ACF tool documentation..."
          cp README.md CHANGELOG.md acf/src/acf/data/acf/
          
          # Copy CLAUDE.md to root
          echo "Copying CLAUDE.md..."
          cp CLAUDE.md acf/src/acf/data/
          
          echo "✅ Package data preparation complete"
          
      - name: Build ACF package
        run: |
          echo "=== Building ACF Package ==="
          cd acf
          uv build
          echo "✅ Package build complete"
          
      - name: Validate package
        run: |
          echo "=== Validating Package ==="
          cd acf
          
          # Check if artifacts were created
          if ls dist/*.whl >/dev/null 2>&1; then
            echo "✅ Wheel file created successfully"
          else
            echo "❌ No wheel file found"
            exit 1
          fi
          
          if ls dist/*.tar.gz >/dev/null 2>&1; then
            echo "✅ Source distribution created successfully"
          else  
            echo "❌ No source distribution found"
            exit 1
          fi
          
          # Test package import
          echo "Testing package import..."
          if uv run python -c "import acf; print('✅ Package imports successfully')"; then
            echo "✅ Package validation passed"
          else
            echo "❌ Package validation failed"
            exit 1
          fi
          
      - name: Run tests
        run: |
          echo "=== Running Tests ==="
          cd acf
          uv run pytest --verbose --tb=short
          echo "✅ Tests completed"
          
      - name: Generate checksums for artifacts
        run: |
          echo "🔍 Generating artifact checksums..."
          cd acf/dist
          
          # Generate SHA256 checksums
          sha256sum *.whl > checksums.txt
          sha256sum *.tar.gz >> checksums.txt
          
          echo "Generated checksums:"
          cat checksums.txt
          
          # Verify checksums
          sha256sum -c checksums.txt
          echo "✅ Checksum generation and verification passed"
          
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package-distributions
          path: acf/dist/
          retention-days: 30
          
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: acf-test-results-${{ github.sha }}
          path: |
            acf/.pytest_cache/
            acf/htmlcov/
            acf/test-results.xml
          retention-days: 7
          if-no-files-found: warn

  create-github-release:
    needs: build
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.create_release == 'true')
    permissions:
      contents: write  # Required for creating releases
      actions: read
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
          
      - name: Set release variables
        run: |
          # Determine release version
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            RELEASE_VERSION=$(grep '^version = ' acf/pyproject.toml | sed 's/version = "//; s/"//')
            if [[ -n "${{ inputs.version_override }}" ]]; then
              RELEASE_VERSION="${{ inputs.version_override }}"
            fi
          else
            RELEASE_VERSION=$(echo "${{ github.ref }}" | sed 's/refs\/tags\/v//')
          fi
          
          # Prerelease detection
          IS_PRERELEASE="false"
          if [[ "$RELEASE_VERSION" =~ (alpha|beta|rc|dev) ]]; then
            IS_PRERELEASE="true"
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.release_type }}" == "prerelease" ]]; then
            IS_PRERELEASE="true"
          fi
          
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "IS_PRERELEASE=$IS_PRERELEASE" >> $GITHUB_ENV
          
      - name: Parse changelog and generate release notes
        run: |
          echo "📄 Parsing changelog and generating release notes..."
          
          # Extract [Unreleased] section from CHANGELOG.md
          CHANGELOG_FILE="CHANGELOG.md"
          RELEASE_NOTES_FILE="release-notes.md"
          
          if [[ -f "$CHANGELOG_FILE" ]]; then
            # Extract content between ## [Unreleased] and next ## heading
            sed -n '/^## \[Unreleased\]/,/^## /p' "$CHANGELOG_FILE" | \
              sed '$d' | \
              tail -n +2 | \
              sed '/^\s*$/d' > "$RELEASE_NOTES_FILE"
              
            # Check if we extracted meaningful content
            if [[ -s "$RELEASE_NOTES_FILE" ]] && [[ $(wc -l < "$RELEASE_NOTES_FILE") -gt 0 ]]; then
              echo "📝 Extracted release notes from CHANGELOG.md:"
              echo "---"
              cat "$RELEASE_NOTES_FILE"
              echo "---"
            else
              echo "⚠️ No meaningful content in [Unreleased] section, generating fallback release notes"
              # Generate fallback release notes from recent commits
              echo "## Release v$RELEASE_VERSION" > "$RELEASE_NOTES_FILE"
              echo "" >> "$RELEASE_NOTES_FILE"
              echo "### Changes" >> "$RELEASE_NOTES_FILE"
              git log --oneline --since="30 days ago" --pretty="- %s" >> "$RELEASE_NOTES_FILE"
              echo "" >> "$RELEASE_NOTES_FILE"
            fi
          else
            echo "⚠️ CHANGELOG.md not found, generating basic release notes"
            echo "## Release v$RELEASE_VERSION" > "$RELEASE_NOTES_FILE"
            echo "" >> "$RELEASE_NOTES_FILE"
            echo "### Changes" >> "$RELEASE_NOTES_FILE"
            git log --oneline --since="30 days ago" --pretty="- %s" >> "$RELEASE_NOTES_FILE"
          fi
          
          # Add installation instructions and metadata
          cat >> "$RELEASE_NOTES_FILE" << EOF
          
          ## Installation
          
          ### Via pip
          \`\`\`bash
          pip install ai-code-forge==$RELEASE_VERSION
          \`\`\`
          
          ### Via uv
          \`\`\`bash
          uv add ai-code-forge==$RELEASE_VERSION
          \`\`\`
          
          ### Via uvx (recommended)
          \`\`\`bash
          uvx ai-code-forge@$RELEASE_VERSION install
          \`\`\`
          
          ## Release Assets
          
          This release includes the following verified artifacts:
          - **Python Wheel**: \`ai_code_forge-$RELEASE_VERSION-py3-none-any.whl\`
          - **Source Distribution**: \`ai_code_forge-$RELEASE_VERSION.tar.gz\`
          - **Checksums**: \`checksums.txt\` (SHA256 verification)
          
          All artifacts are cryptographically signed via Sigstore for supply chain security.
          EOF
          
          echo "🎨 Final release notes:"
          echo "===================================="
          cat "$RELEASE_NOTES_FILE"
          echo "===================================="
          
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "🚀 Creating GitHub release..."
          
          # Determine draft status
          DRAFT_FLAG=""
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ inputs.release_type }}" == "draft" ]]; then
            DRAFT_FLAG="--draft"
          fi
          
          # Determine prerelease flag
          PRERELEASE_FLAG=""
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          # Create the release
          RELEASE_TAG="v$RELEASE_VERSION"
          
          # For workflow_dispatch, create tag if it doesn't exist
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if ! git tag --list | grep -q "^$RELEASE_TAG$"; then
              echo "Creating tag: $RELEASE_TAG"
              git tag "$RELEASE_TAG"
              git push origin "$RELEASE_TAG"
            fi
          fi
          
          # Create release with comprehensive validation
          gh release create "$RELEASE_TAG" \
            --title "AI Code Forge v$RELEASE_VERSION" \
            --notes-file "release-notes.md" \
            $DRAFT_FLAG \
            $PRERELEASE_FLAG \
            --verify-tag \
            dist/*.whl \
            dist/*.tar.gz \
            dist/checksums.txt
          
          # Get release URL for summary
          RELEASE_URL=$(gh release view "$RELEASE_TAG" --json url --jq '.url')
          echo "RELEASE_URL=$RELEASE_URL" >> $GITHUB_ENV
          
          echo "✅ GitHub release created successfully!"
          echo "Release URL: $RELEASE_URL"

  publish-to-pypi:
    needs: [build, create-github-release]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    environment:
      name: pypi
      url: https://pypi.org/project/ai-code-forge/
    
    permissions:
      id-token: write        # REQUIRED for OIDC authentication
      contents: read         # Download artifacts
      attestations: write    # Generate Sigstore attestations
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
      
      - name: Verify artifacts before publishing
        run: |
          echo "🔍 Pre-publish artifact verification..."
          ls -la dist/
          
          # Verify expected files exist
          [[ -f dist/*.whl ]] || { echo "❌ Wheel missing"; exit 1; }
          [[ -f dist/*.tar.gz ]] || { echo "❌ Source dist missing"; exit 1; }
          [[ -f dist/checksums.txt ]] || { echo "❌ Checksums missing"; exit 1; }
          
          # Verify checksums
          cd dist
          sha256sum -c checksums.txt || { echo "❌ Checksum verification failed"; exit 1; }
          cd ..
          
          echo "✅ All artifact verification passed"
      
      - name: Publish to PyPI via OIDC with Sigstore attestations
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          attestations: true           # Enable Sigstore attestations (automatic signing)
          verify-metadata: true        # Verify package metadata
          verbose: true               # Debug output for troubleshooting
          skip-existing: false        # Fail on duplicates for security
          print-hash: true           # Log file hashes for audit trail
      
      - name: Verify attestations were created
        run: |
          echo "🔐 Verifying Sigstore attestations were generated..."
          
          # Note: Attestations are automatically generated and verified by PyPI
          # This step confirms the publishing process completed with attestations
          echo "✅ Package published with Sigstore attestations"
          echo "📋 Attestations include:"
          echo "  - Build provenance (SLSA Level 3)"
          echo "  - Repository identity binding"
          echo "  - Cryptographic signatures"
          echo "  - Transparency log entries"
          
          # Store PyPI URL for summary
          RELEASE_VERSION=$(echo "${{ github.ref }}" | sed 's/refs\/tags\/v//')
          echo "PYPI_URL=https://pypi.org/project/ai-code-forge/$RELEASE_VERSION/" >> $GITHUB_ENV
          
  build-summary:
    needs: [build, create-github-release, publish-to-pypi]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
    
    steps:
      - name: Download build artifacts for summary
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
          
      - name: Generate build summary
        run: |
          echo "🎉 ACF CLI Build and Release Complete!"
          echo ""
          echo "📦 Generated artifacts:"
          ls -la dist/
          echo ""
          echo "📊 Package sizes:"
          du -h dist/*
          echo ""
          
          # Release status
          if [[ "${{ needs.create-github-release.result }}" == "success" ]]; then
            echo "🏪 GitHub Release: ✅ Created"
            if [[ -n "${RELEASE_URL:-}" ]]; then
              echo "Release URL: $RELEASE_URL"
            fi
          else
            echo "🏪 GitHub Release: ⏭️ Skipped (no release trigger)"
          fi
          
          # PyPI status
          if [[ "${{ needs.publish-to-pypi.result }}" == "success" ]]; then
            echo "📦 PyPI Publishing: ✅ Published with Sigstore attestations"
            if [[ -n "${PYPI_URL:-}" ]]; then
              echo "PyPI URL: $PYPI_URL"
            fi
            echo ""
            echo "🔐 Security Features:"
            echo "  ✅ OIDC trusted publishing (no API keys)"
            echo "  ✅ Sigstore keyless signing" 
            echo "  ✅ SLSA Level 3 provenance"
            echo "  ✅ Cryptographic attestations"
            echo "  ✅ Transparency log entries"
          elif [[ "${{ needs.publish-to-pypi.result }}" == "skipped" ]]; then
            echo "📦 PyPI Publishing: ⏭️ Skipped (not a tag-based release)"
          else
            echo "📦 PyPI Publishing: ❌ Failed"
          fi
          
          echo ""
          echo "💾 Installation Commands:"
          RELEASE_VERSION=$(grep '^version = ' acf/pyproject.toml 2>/dev/null | sed 's/version = "//; s/"//' || echo "latest")
          echo "  pip install ai-code-forge==$RELEASE_VERSION"
          echo "  uv add ai-code-forge==$RELEASE_VERSION"
          echo "  uvx ai-code-forge@$RELEASE_VERSION install"